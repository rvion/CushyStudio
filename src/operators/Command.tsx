import { commandManager, type CushyShortcut } from '../app/shortcuts/CommandManager'
import { BoundCommandSym } from './introspect/_isBoundCommand'
import { CommandSym } from './introspect/_isCommand'
import { RET } from './RET'

// ------------------------------------------------------------------------------------------
// COMMAND MANAGER Centralize every single command
// export class CommandManager {
//     commands: Map<Command['id'], Command> = new Map()
//     commandByCombo: Map<string, Command[]> = new Map()

//     registerCommand = (op: Command) => {
//         this.commands.set(op.id, op)

//     }

//     getCommandById = (id: string) => this.commands.get(id)
// }

// ------------------------------------------------------------------------------------------
// COMMAND = a function with a name, a description, and a condition whether it can be started or not
type Command_<Ctx = any> = {
    combos?: CushyShortcut | CushyShortcut[]
    label: string
    id: string // ‚ùì make optional ; autogenerated ?
    description?: string
    ctx: CommandContext<Ctx>
    action: (t: Ctx) => RET | Promise<RET>
    // keymap
    validInInput?: boolean
    continueAfterSuccess?: boolean
    // menu?: (p: Props, t: Ctx) => MenuEntry[]
    /** menuEntries */
}

// ------------------------------------------------------------------------------------------
export interface Command<Ctx = any> extends Command_<Ctx> {}
export class Command<Ctx = any> {
    $SYM = CommandSym

    constructor(public conf: Command_<Ctx>) {
        Object.assign(this, conf)
    }

    bind = (ctx: Ctx): BoundCommand<Ctx> => new BoundCommand(this, ctx)

    /**
     * method to programmatically call a command,
     * using when to both extract context and check if command can run
     * */
    execute = () => {
        console.warn(`[CMD] ‚ò£Ô∏è TRYING TO RUN... ${this.label}`)
        const context = this.conf.ctx.check()
        if (context === RET.UNMATCHED) {
            console.warn(`[CMD] üî¥ FAILED TO RUN`)
            return RET.UNMATCHED
        }
        const res = this.conf.action?.(context!)
        return res
    }

    NavBarBtnUI = (p: { label?: string }) => <div onClick={this.execute}>{p.label ?? this.label}</div>
}

// ------------------------------------------------------------------------------------------
export class CommandContext<Ctx = any> {
    constructor(
        /** display name */
        public name: string,
        /** actual function code */
        public check: () => Ctx | RET.UNMATCHED,
    ) {}
}

// small helper to create commands and register them globally
export function command<Ctx extends any>(t: Omit<Command_<Ctx>, 'type'>): Command<Ctx> {
    const cmd = new Command(t as any)
    commandManager.registerCommand(cmd)
    return cmd
}

// ------------------------------------------------------------------------------------------
// A bound command; ready to be executed
export type BoundCommandOpts = { label?: string }
export class BoundCommand<Ctx = any> {
    $SYM = BoundCommandSym
    constructor(
        //
        private command: Command<Ctx>,
        private ctx: Ctx,
        private ui?: BoundCommandOpts,
    ) {}

    execute = () => {
        return this.command.conf.action(this.ctx)
    }

    NavBarBtnUI = (p: { label?: string }) => {
        return <div onClick={this.execute}>{p.label ?? this.label}</div>
    }

    get label() {
        return this.ui?.label ?? this.command.label
    }
}
