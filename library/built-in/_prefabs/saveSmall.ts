import type { OutputFor } from './_prefabs'

export type UI_customSave = X.XOptional<
    X.XGroup<{
        subfolder: X.XString
        format: X.XSelectOne<
            | { id: 'raw'; label: 'Raw' }
            | { id: 'image/webp'; label: 'WebP' }
            | { id: 'image/png'; label: 'PNG' }
            | { id: 'image/jpeg'; label: 'JPG' }
        >
        quality: X.XNumber
    }>
>

export function ui_customSave(): UI_customSave {
    const form = getCurrentForm()
    return form
        .group({
            label: 'Save As...',
            icon: 'mdiContentSaveCogOutline',
            items: {
                subfolder: form.string({
                    label: 'Subfolder',
                    tooltip: [
                        //
                        'Apply to all images generated by prompt',
                        'leave blank to save in same subfolder as ComfyUI outputs.',
                        'tokens: {YYYY}, {MM}, {DD}, {HH}, {mm}, {ss}',
                    ].join('\n'),
                    default: '{YYYY}-{MM}-{DD}/{HH}h{mm}-{ss}',
                }),
                format: form.selectOne({
                    label: 'Format',
                    appearance: 'tab',
                    default: { id: 'raw', label: 'Raw' },
                    choices: [
                        { id: 'raw', label: 'Raw' },
                        { id: 'image/webp', label: 'WebP' },
                        { id: 'image/png', label: 'PNG' },
                        { id: 'image/jpeg', label: 'JPG' },
                    ],
                }),
                quality: form.float({
                    tooltip: 'only when saving as WebP or JPG',
                    default: 0.9,
                    min: 0,
                    max: 1,
                    step: 0.1,
                }),
            },
        })
        .optional(true)
}

export const run_customSave = (ui: OutputFor<typeof ui_customSave>): ImageSaveFormat | undefined => {
    if (ui == null) return undefined
    const now = new Date()
    return {
        format: ui.format.id,
        prefix: ui.subfolder //
            .replaceAll('{YYYY}', now.getFullYear().toString())
            .replaceAll('{MM}', (now.getMonth() + 1).toString())
            .replaceAll('{DD}', now.getDate().toString())
            .replaceAll('{HH}', now.getHours().toString().padStart(2, '0'))
            .replaceAll('{mm}', now.getMinutes().toString().padStart(2, '0'))
            .replaceAll('{ss}', now.getSeconds().toString().padStart(2, '0')),
        quality: ui.quality,
    }
}

// old way:
// ğŸ’½ /** need to be called after `await run.PROMPT()`, not before */
// ğŸ’½ export const run_saveAllImages = async (p: ImageSaveFormat = {}) => {
// ğŸ’½     const run = getCurrentRun()
// ğŸ’½     // 1. build canvas
// ğŸ’½     const canvas = document.createElement('canvas')
// ğŸ’½     let ctx = canvas.getContext('2d')
// ğŸ’½
// ğŸ’½     console.log(`[ğŸ’ª] found ${run.generatedImages.length} images`)
// ğŸ’½
// ğŸ’½     // 2. for every image generated
// ğŸ’½     for (const img of run.generatedImages) {
// ğŸ’½         // if (img.ComfyNodeMetadta?.tag !== 'final-image') {
// ğŸ’½         //     console.log(`[ğŸ’ª] skipping file ${img.url} because it doesnt' have tag "final-image"`)
// ğŸ’½         //     continue
// ğŸ’½         // }
// ğŸ’½         // get canvas size (use 'image-meta' that supports all the image file formats you can think of)
// ğŸ’½         const width = img.data.width
// ğŸ’½         const height = img.data.height
// ğŸ’½
// ğŸ’½         // resize the canvas accordingly
// ğŸ’½         canvas.width = width
// ğŸ’½         canvas.height = height
// ğŸ’½
// ğŸ’½         // paste html image onto your canvas
// ğŸ’½         const imgHtml = await run.Konva.createHTMLImage_fromURL(img.url)
// ğŸ’½         ctx!.drawImage(imgHtml, 0, 0, width, height)
// ğŸ’½
// ğŸ’½         // get the binary image data (as base64)
// ğŸ’½         // (https://developer.mozilla.org/docs/Web/API/HTMLCanvasElement/toDataURL)
// ğŸ’½         let dataUrl = canvas.toDataURL('image/webp', p.quality)
// ğŸ’½         let base64Data = dataUrl.replace(/^data:image\/webp;base64,/, '')
// ğŸ’½
// ğŸ’½         // non-integrated with CushyStudio way of saving an image
// ğŸ’½         run.Filesystem.mkdirSync('outputs/_b64', { recursive: true })
// ğŸ’½         const relPath = `outputs/_b64/output-${img.id}.webp` as RelativePath
// ğŸ’½         run.Filesystem.writeFileSync(relPath, base64Data, 'base64')
// ğŸ’½
// ğŸ’½         // register it on cushy
// ğŸ’½         const newImg = run.Images.createFromPath(relPath, { promptID: img.prompt?.id })
// ğŸ’½     }
// ğŸ’½ }
